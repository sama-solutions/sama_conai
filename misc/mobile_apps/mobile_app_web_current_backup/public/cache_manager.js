/**\n * SAMA CONAI - Gestionnaire de Cache AvancÃ©\n * SystÃ¨me de cache local avec synchronisation intelligente\n * AmÃ©liore drastiquement les performances de l'application mobile\n */\n\nclass CacheManager {\n    constructor() {\n        this.cacheName = 'sama_conai_cache';\n        this.cacheVersion = '1.0.0';\n        this.maxCacheAge = 5 * 60 * 1000; // 5 minutes\n        this.syncQueue = [];\n        this.isOnline = navigator.onLine;\n        this.lastSyncTime = null;\n        \n        // Initialiser les Ã©vÃ©nements de connexion\n        this.initConnectionEvents();\n        \n        // Charger les donnÃ©es en cache au dÃ©marrage\n        this.loadCacheFromStorage();\n        \n        console.log('ðŸš€ CacheManager initialisÃ© - Mode:', this.isOnline ? 'Online' : 'Offline');\n    }\n\n    /**\n     * Initialiser les Ã©vÃ©nements de connexion\n     */\n    initConnectionEvents() {\n        window.addEventListener('online', () => {\n            console.log('ðŸŒ Connexion rÃ©tablie');\n            this.isOnline = true;\n            this.syncPendingData();\n        });\n\n        window.addEventListener('offline', () => {\n            console.log('ðŸ“¡ Connexion perdue - Mode cache activÃ©');\n            this.isOnline = false;\n        });\n    }\n\n    /**\n     * Charger les donnÃ©es du cache depuis localStorage\n     */\n    loadCacheFromStorage() {\n        try {\n            const cached = localStorage.getItem(this.cacheName);\n            if (cached) {\n                this.cache = JSON.parse(cached);\n                console.log('ðŸ“‚ Cache chargÃ©:', Object.keys(this.cache).length, 'entrÃ©es');\n            } else {\n                this.cache = {};\n            }\n        } catch (error) {\n            console.error('âŒ Erreur chargement cache:', error);\n            this.cache = {};\n        }\n    }\n\n    /**\n     * Sauvegarder le cache dans localStorage\n     */\n    saveCacheToStorage() {\n        try {\n            localStorage.setItem(this.cacheName, JSON.stringify(this.cache));\n            console.log('ðŸ’¾ Cache sauvegardÃ©');\n        } catch (error) {\n            console.error('âŒ Erreur sauvegarde cache:', error);\n        }\n    }\n\n    /**\n     * GÃ©nÃ©rer une clÃ© de cache unique\n     */\n    generateCacheKey(url, params = {}) {\n        const paramString = Object.keys(params)\n            .sort()\n            .map(key => `${key}=${params[key]}`)\n            .join('&');\n        return `${url}${paramString ? '?' + paramString : ''}`;\n    }\n\n    /**\n     * VÃ©rifier si une entrÃ©e de cache est valide\n     */\n    isCacheValid(cacheEntry) {\n        if (!cacheEntry || !cacheEntry.timestamp) {\n            return false;\n        }\n        \n        const age = Date.now() - cacheEntry.timestamp;\n        return age < this.maxCacheAge;\n    }\n\n    /**\n     * RÃ©cupÃ©rer des donnÃ©es du cache\n     */\n    get(key) {\n        const cacheEntry = this.cache[key];\n        \n        if (!cacheEntry) {\n            console.log('ðŸ“­ Cache miss:', key);\n            return null;\n        }\n\n        if (!this.isCacheValid(cacheEntry)) {\n            console.log('â° Cache expirÃ©:', key);\n            delete this.cache[key];\n            this.saveCacheToStorage();\n            return null;\n        }\n\n        console.log('âš¡ Cache hit:', key);\n        return cacheEntry.data;\n    }\n\n    /**\n     * Stocker des donnÃ©es dans le cache\n     */\n    set(key, data, options = {}) {\n        const cacheEntry = {\n            data: data,\n            timestamp: Date.now(),\n            version: this.cacheVersion,\n            priority: options.priority || 'normal', // high, normal, low\n            persistent: options.persistent || false // true pour les donnÃ©es critiques\n        };\n\n        this.cache[key] = cacheEntry;\n        this.saveCacheToStorage();\n        \n        console.log('ðŸ’¾ DonnÃ©es mises en cache:', key);\n    }\n\n    /**\n     * Supprimer une entrÃ©e du cache\n     */\n    delete(key) {\n        if (this.cache[key]) {\n            delete this.cache[key];\n            this.saveCacheToStorage();\n            console.log('ðŸ—‘ï¸ Cache supprimÃ©:', key);\n        }\n    }\n\n    /**\n     * Vider tout le cache\n     */\n    clear() {\n        this.cache = {};\n        this.saveCacheToStorage();\n        console.log('ðŸ§¹ Cache vidÃ© complÃ¨tement');\n    }\n\n    /**\n     * Nettoyer les entrÃ©es expirÃ©es\n     */\n    cleanup() {\n        let cleaned = 0;\n        const now = Date.now();\n        \n        Object.keys(this.cache).forEach(key => {\n            const entry = this.cache[key];\n            if (!entry.persistent && (now - entry.timestamp) > this.maxCacheAge) {\n                delete this.cache[key];\n                cleaned++;\n            }\n        });\n\n        if (cleaned > 0) {\n            this.saveCacheToStorage();\n            console.log('ðŸ§¹ Cache nettoyÃ©:', cleaned, 'entrÃ©es supprimÃ©es');\n        }\n    }\n\n    /**\n     * Ajouter une opÃ©ration Ã  la queue de synchronisation\n     */\n    addToSyncQueue(operation) {\n        operation.timestamp = Date.now();\n        operation.id = this.generateSyncId();\n        \n        this.syncQueue.push(operation);\n        this.saveSyncQueue();\n        \n        console.log('ðŸ“¤ OpÃ©ration ajoutÃ©e Ã  la queue de sync:', operation.type);\n        \n        // Tenter la synchronisation si en ligne\n        if (this.isOnline) {\n            this.syncPendingData();\n        }\n    }\n\n    /**\n     * GÃ©nÃ©rer un ID unique pour les opÃ©rations de sync\n     */\n    generateSyncId() {\n        return Date.now().toString(36) + Math.random().toString(36).substr(2);\n    }\n\n    /**\n     * Sauvegarder la queue de synchronisation\n     */\n    saveSyncQueue() {\n        try {\n            localStorage.setItem(this.cacheName + '_sync_queue', JSON.stringify(this.syncQueue));\n        } catch (error) {\n            console.error('âŒ Erreur sauvegarde queue sync:', error);\n        }\n    }\n\n    /**\n     * Charger la queue de synchronisation\n     */\n    loadSyncQueue() {\n        try {\n            const queue = localStorage.getItem(this.cacheName + '_sync_queue');\n            if (queue) {\n                this.syncQueue = JSON.parse(queue);\n                console.log('ðŸ“¥ Queue de sync chargÃ©e:', this.syncQueue.length, 'opÃ©rations');\n            }\n        } catch (error) {\n            console.error('âŒ Erreur chargement queue sync:', error);\n            this.syncQueue = [];\n        }\n    }\n\n    /**\n     * Synchroniser les donnÃ©es en attente\n     */\n    async syncPendingData() {\n        if (!this.isOnline || this.syncQueue.length === 0) {\n            return;\n        }\n\n        console.log('ðŸ”„ DÃ©but synchronisation:', this.syncQueue.length, 'opÃ©rations');\n        \n        const operations = [...this.syncQueue];\n        this.syncQueue = [];\n        \n        for (const operation of operations) {\n            try {\n                await this.processSyncOperation(operation);\n                console.log('âœ… OpÃ©ration synchronisÃ©e:', operation.type);\n            } catch (error) {\n                console.error('âŒ Erreur sync opÃ©ration:', operation.type, error);\n                // Remettre en queue si erreur\n                this.syncQueue.push(operation);\n            }\n        }\n        \n        this.saveSyncQueue();\n        this.lastSyncTime = Date.now();\n        \n        console.log('ðŸ”„ Synchronisation terminÃ©e');\n    }\n\n    /**\n     * Traiter une opÃ©ration de synchronisation\n     */\n    async processSyncOperation(operation) {\n        switch (operation.type) {\n            case 'create_request':\n                return await this.syncCreateRequest(operation.data);\n            case 'update_profile':\n                return await this.syncUpdateProfile(operation.data);\n            case 'mark_read':\n                return await this.syncMarkAsRead(operation.data);\n            default:\n                console.warn('âš ï¸ Type d\\'opÃ©ration sync inconnue:', operation.type);\n        }\n    }\n\n    /**\n     * Synchroniser la crÃ©ation d'une demande\n     */\n    async syncCreateRequest(data) {\n        const response = await fetch('/api/mobile/citizen/requests', {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json',\n                'Authorization': `Bearer ${authToken}`\n            },\n            body: JSON.stringify(data)\n        });\n        \n        if (!response.ok) {\n            throw new Error(`Erreur sync create_request: ${response.status}`);\n        }\n        \n        // Invalider le cache des demandes\n        this.invalidatePattern('/api/mobile/citizen/requests');\n        \n        return await response.json();\n    }\n\n    /**\n     * Synchroniser la mise Ã  jour du profil\n     */\n    async syncUpdateProfile(data) {\n        const response = await fetch('/api/mobile/citizen/profile', {\n            method: 'PUT',\n            headers: {\n                'Content-Type': 'application/json',\n                'Authorization': `Bearer ${authToken}`\n            },\n            body: JSON.stringify(data)\n        });\n        \n        if (!response.ok) {\n            throw new Error(`Erreur sync update_profile: ${response.status}`);\n        }\n        \n        // Invalider le cache du profil\n        this.invalidatePattern('/api/mobile/citizen/profile');\n        \n        return await response.json();\n    }\n\n    /**\n     * Invalider les entrÃ©es de cache correspondant Ã  un pattern\n     */\n    invalidatePattern(pattern) {\n        const keysToDelete = Object.keys(this.cache).filter(key => key.includes(pattern));\n        \n        keysToDelete.forEach(key => {\n            delete this.cache[key];\n        });\n        \n        if (keysToDelete.length > 0) {\n            this.saveCacheToStorage();\n            console.log('ðŸ—‘ï¸ Cache invalidÃ©:', keysToDelete.length, 'entrÃ©es pour pattern:', pattern);\n        }\n    }\n\n    /**\n     * PrÃ©charger les donnÃ©es critiques\n     */\n    async preloadCriticalData() {\n        if (!this.isOnline) {\n            return;\n        }\n\n        console.log('ðŸš€ PrÃ©chargement des donnÃ©es critiques...');\n        \n        const criticalEndpoints = [\n            '/api/mobile/citizen/dashboard',\n            '/api/mobile/citizen/requests',\n            '/api/mobile/citizen/profile'\n        ];\n\n        for (const endpoint of criticalEndpoints) {\n            try {\n                const cacheKey = this.generateCacheKey(endpoint);\n                \n                // VÃ©rifier si dÃ©jÃ  en cache et valide\n                if (this.get(cacheKey)) {\n                    continue;\n                }\n\n                const response = await fetch(endpoint, {\n                    headers: {\n                        'Authorization': `Bearer ${authToken}`\n                    }\n                });\n\n                if (response.ok) {\n                    const data = await response.json();\n                    this.set(cacheKey, data, { priority: 'high', persistent: true });\n                    console.log('ðŸ“¦ DonnÃ©es prÃ©chargÃ©es:', endpoint);\n                }\n            } catch (error) {\n                console.error('âŒ Erreur prÃ©chargement:', endpoint, error);\n            }\n        }\n    }\n\n    /**\n     * Obtenir les statistiques du cache\n     */\n    getStats() {\n        const entries = Object.keys(this.cache);\n        const totalSize = JSON.stringify(this.cache).length;\n        const validEntries = entries.filter(key => this.isCacheValid(this.cache[key]));\n        \n        return {\n            totalEntries: entries.length,\n            validEntries: validEntries.length,\n            expiredEntries: entries.length - validEntries.length,\n            totalSize: totalSize,\n            syncQueueSize: this.syncQueue.length,\n            lastSyncTime: this.lastSyncTime,\n            isOnline: this.isOnline\n        };\n    }\n\n    /**\n     * Afficher les statistiques du cache\n     */\n    logStats() {\n        const stats = this.getStats();\n        console.log('ðŸ“Š Statistiques Cache SAMA CONAI:');\n        console.log('   ðŸ“¦ EntrÃ©es totales:', stats.totalEntries);\n        console.log('   âœ… EntrÃ©es valides:', stats.validEntries);\n        console.log('   â° EntrÃ©es expirÃ©es:', stats.expiredEntries);\n        console.log('   ðŸ’¾ Taille totale:', Math.round(stats.totalSize / 1024), 'KB');\n        console.log('   ðŸ“¤ Queue sync:', stats.syncQueueSize, 'opÃ©rations');\n        console.log('   ðŸ”„ DerniÃ¨re sync:', stats.lastSyncTime ? new Date(stats.lastSyncTime).toLocaleTimeString() : 'Jamais');\n        console.log('   ðŸŒ Ã‰tat:', stats.isOnline ? 'En ligne' : 'Hors ligne');\n    }\n}\n\n// Instance globale du gestionnaire de cache\nconst cacheManager = new CacheManager();\n\n/**\n * Wrapper pour les appels fetch avec cache intelligent\n */\nasync function fetchWithCache(url, options = {}, cacheOptions = {}) {\n    const cacheKey = cacheManager.generateCacheKey(url, options.params || {});\n    \n    // VÃ©rifier le cache d'abord\n    const cachedData = cacheManager.get(cacheKey);\n    if (cachedData && !options.forceRefresh) {\n        console.log('âš¡ DonnÃ©es servies depuis le cache:', url);\n        return {\n            ...cachedData,\n            fromCache: true,\n            cacheTimestamp: cacheManager.cache[cacheKey].timestamp\n        };\n    }\n\n    // Si hors ligne et pas de cache, retourner erreur\n    if (!cacheManager.isOnline && !cachedData) {\n        throw new Error('DonnÃ©es non disponibles hors ligne');\n    }\n\n    // Si hors ligne mais cache disponible, le retourner avec avertissement\n    if (!cacheManager.isOnline && cachedData) {\n        console.log('ðŸ“¡ Mode hors ligne - donnÃ©es du cache (possiblement obsolÃ¨tes):', url);\n        return {\n            ...cachedData,\n            fromCache: true,\n            offline: true,\n            cacheTimestamp: cacheManager.cache[cacheKey].timestamp\n        };\n    }\n\n    // Faire l'appel rÃ©seau\n    try {\n        console.log('ðŸŒ Appel rÃ©seau:', url);\n        \n        const fetchOptions = {\n            ...options,\n            headers: {\n                'Content-Type': 'application/json',\n                ...options.headers\n            }\n        };\n\n        const response = await fetch(url, fetchOptions);\n        \n        if (!response.ok) {\n            throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n        }\n\n        const data = await response.json();\n        \n        // Mettre en cache si succÃ¨s\n        if (data.success) {\n            cacheManager.set(cacheKey, data, {\n                priority: cacheOptions.priority || 'normal',\n                persistent: cacheOptions.persistent || false\n            });\n        }\n\n        return {\n            ...data,\n            fromCache: false,\n            networkTimestamp: Date.now()\n        };\n        \n    } catch (error) {\n        console.error('âŒ Erreur rÃ©seau:', url, error);\n        \n        // En cas d'erreur, retourner le cache si disponible\n        if (cachedData) {\n            console.log('ðŸ”„ Fallback vers cache aprÃ¨s erreur rÃ©seau:', url);\n            return {\n                ...cachedData,\n                fromCache: true,\n                networkError: error.message,\n                cacheTimestamp: cacheManager.cache[cacheKey].timestamp\n            };\n        }\n        \n        throw error;\n    }\n}\n\n/**\n * Fonction pour invalider le cache lors de modifications\n */\nfunction invalidateCache(pattern) {\n    cacheManager.invalidatePattern(pattern);\n}\n\n/**\n * Fonction pour ajouter une opÃ©ration Ã  la queue de sync\n */\nfunction addToSyncQueue(type, data) {\n    cacheManager.addToSyncQueue({ type, data });\n}\n\n/**\n * Fonction pour forcer la synchronisation\n */\nfunction forcSync() {\n    return cacheManager.syncPendingData();\n}\n\n/**\n * Fonction pour prÃ©charger les donnÃ©es critiques\n */\nfunction preloadData() {\n    return cacheManager.preloadCriticalData();\n}\n\n/**\n * Fonction pour obtenir les stats du cache\n */\nfunction getCacheStats() {\n    return cacheManager.getStats();\n}\n\n/**\n * Fonction pour nettoyer le cache\n */\nfunction cleanupCache() {\n    cacheManager.cleanup();\n}\n\n// Nettoyer le cache pÃ©riodiquement\nsetInterval(() => {\n    cacheManager.cleanup();\n}, 60000); // Toutes les minutes\n\n// PrÃ©charger les donnÃ©es au dÃ©marrage si connectÃ©\nif (cacheManager.isOnline) {\n    setTimeout(() => {\n        cacheManager.preloadCriticalData();\n    }, 2000);\n}\n\n// Exposer les fonctions globalement\nwindow.fetchWithCache = fetchWithCache;\nwindow.invalidateCache = invalidateCache;\nwindow.addToSyncQueue = addToSyncQueue;\nwindow.forcSync = forcSync;\nwindow.preloadData = preloadData;\nwindow.getCacheStats = getCacheStats;\nwindow.cleanupCache = cleanupCache;\nwindow.cacheManager = cacheManager;\n\nconsole.log('ðŸš€ SystÃ¨me de cache SAMA CONAI initialisÃ©');"