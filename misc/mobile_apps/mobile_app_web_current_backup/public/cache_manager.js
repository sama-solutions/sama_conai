/**\n * SAMA CONAI - Gestionnaire de Cache Avancé\n * Système de cache local avec synchronisation intelligente\n * Améliore drastiquement les performances de l'application mobile\n */\n\nclass CacheManager {\n    constructor() {\n        this.cacheName = 'sama_conai_cache';\n        this.cacheVersion = '1.0.0';\n        this.maxCacheAge = 5 * 60 * 1000; // 5 minutes\n        this.syncQueue = [];\n        this.isOnline = navigator.onLine;\n        this.lastSyncTime = null;\n        \n        // Initialiser les événements de connexion\n        this.initConnectionEvents();\n        \n        // Charger les données en cache au démarrage\n        this.loadCacheFromStorage();\n        \n        console.log('🚀 CacheManager initialisé - Mode:', this.isOnline ? 'Online' : 'Offline');\n    }\n\n    /**\n     * Initialiser les événements de connexion\n     */\n    initConnectionEvents() {\n        window.addEventListener('online', () => {\n            console.log('🌐 Connexion rétablie');\n            this.isOnline = true;\n            this.syncPendingData();\n        });\n\n        window.addEventListener('offline', () => {\n            console.log('📡 Connexion perdue - Mode cache activé');\n            this.isOnline = false;\n        });\n    }\n\n    /**\n     * Charger les données du cache depuis localStorage\n     */\n    loadCacheFromStorage() {\n        try {\n            const cached = localStorage.getItem(this.cacheName);\n            if (cached) {\n                this.cache = JSON.parse(cached);\n                console.log('📂 Cache chargé:', Object.keys(this.cache).length, 'entrées');\n            } else {\n                this.cache = {};\n            }\n        } catch (error) {\n            console.error('❌ Erreur chargement cache:', error);\n            this.cache = {};\n        }\n    }\n\n    /**\n     * Sauvegarder le cache dans localStorage\n     */\n    saveCacheToStorage() {\n        try {\n            localStorage.setItem(this.cacheName, JSON.stringify(this.cache));\n            console.log('💾 Cache sauvegardé');\n        } catch (error) {\n            console.error('❌ Erreur sauvegarde cache:', error);\n        }\n    }\n\n    /**\n     * Générer une clé de cache unique\n     */\n    generateCacheKey(url, params = {}) {\n        const paramString = Object.keys(params)\n            .sort()\n            .map(key => `${key}=${params[key]}`)\n            .join('&');\n        return `${url}${paramString ? '?' + paramString : ''}`;\n    }\n\n    /**\n     * Vérifier si une entrée de cache est valide\n     */\n    isCacheValid(cacheEntry) {\n        if (!cacheEntry || !cacheEntry.timestamp) {\n            return false;\n        }\n        \n        const age = Date.now() - cacheEntry.timestamp;\n        return age < this.maxCacheAge;\n    }\n\n    /**\n     * Récupérer des données du cache\n     */\n    get(key) {\n        const cacheEntry = this.cache[key];\n        \n        if (!cacheEntry) {\n            console.log('📭 Cache miss:', key);\n            return null;\n        }\n\n        if (!this.isCacheValid(cacheEntry)) {\n            console.log('⏰ Cache expiré:', key);\n            delete this.cache[key];\n            this.saveCacheToStorage();\n            return null;\n        }\n\n        console.log('⚡ Cache hit:', key);\n        return cacheEntry.data;\n    }\n\n    /**\n     * Stocker des données dans le cache\n     */\n    set(key, data, options = {}) {\n        const cacheEntry = {\n            data: data,\n            timestamp: Date.now(),\n            version: this.cacheVersion,\n            priority: options.priority || 'normal', // high, normal, low\n            persistent: options.persistent || false // true pour les données critiques\n        };\n\n        this.cache[key] = cacheEntry;\n        this.saveCacheToStorage();\n        \n        console.log('💾 Données mises en cache:', key);\n    }\n\n    /**\n     * Supprimer une entrée du cache\n     */\n    delete(key) {\n        if (this.cache[key]) {\n            delete this.cache[key];\n            this.saveCacheToStorage();\n            console.log('🗑️ Cache supprimé:', key);\n        }\n    }\n\n    /**\n     * Vider tout le cache\n     */\n    clear() {\n        this.cache = {};\n        this.saveCacheToStorage();\n        console.log('🧹 Cache vidé complètement');\n    }\n\n    /**\n     * Nettoyer les entrées expirées\n     */\n    cleanup() {\n        let cleaned = 0;\n        const now = Date.now();\n        \n        Object.keys(this.cache).forEach(key => {\n            const entry = this.cache[key];\n            if (!entry.persistent && (now - entry.timestamp) > this.maxCacheAge) {\n                delete this.cache[key];\n                cleaned++;\n            }\n        });\n\n        if (cleaned > 0) {\n            this.saveCacheToStorage();\n            console.log('🧹 Cache nettoyé:', cleaned, 'entrées supprimées');\n        }\n    }\n\n    /**\n     * Ajouter une opération à la queue de synchronisation\n     */\n    addToSyncQueue(operation) {\n        operation.timestamp = Date.now();\n        operation.id = this.generateSyncId();\n        \n        this.syncQueue.push(operation);\n        this.saveSyncQueue();\n        \n        console.log('📤 Opération ajoutée à la queue de sync:', operation.type);\n        \n        // Tenter la synchronisation si en ligne\n        if (this.isOnline) {\n            this.syncPendingData();\n        }\n    }\n\n    /**\n     * Générer un ID unique pour les opérations de sync\n     */\n    generateSyncId() {\n        return Date.now().toString(36) + Math.random().toString(36).substr(2);\n    }\n\n    /**\n     * Sauvegarder la queue de synchronisation\n     */\n    saveSyncQueue() {\n        try {\n            localStorage.setItem(this.cacheName + '_sync_queue', JSON.stringify(this.syncQueue));\n        } catch (error) {\n            console.error('❌ Erreur sauvegarde queue sync:', error);\n        }\n    }\n\n    /**\n     * Charger la queue de synchronisation\n     */\n    loadSyncQueue() {\n        try {\n            const queue = localStorage.getItem(this.cacheName + '_sync_queue');\n            if (queue) {\n                this.syncQueue = JSON.parse(queue);\n                console.log('📥 Queue de sync chargée:', this.syncQueue.length, 'opérations');\n            }\n        } catch (error) {\n            console.error('❌ Erreur chargement queue sync:', error);\n            this.syncQueue = [];\n        }\n    }\n\n    /**\n     * Synchroniser les données en attente\n     */\n    async syncPendingData() {\n        if (!this.isOnline || this.syncQueue.length === 0) {\n            return;\n        }\n\n        console.log('🔄 Début synchronisation:', this.syncQueue.length, 'opérations');\n        \n        const operations = [...this.syncQueue];\n        this.syncQueue = [];\n        \n        for (const operation of operations) {\n            try {\n                await this.processSyncOperation(operation);\n                console.log('✅ Opération synchronisée:', operation.type);\n            } catch (error) {\n                console.error('❌ Erreur sync opération:', operation.type, error);\n                // Remettre en queue si erreur\n                this.syncQueue.push(operation);\n            }\n        }\n        \n        this.saveSyncQueue();\n        this.lastSyncTime = Date.now();\n        \n        console.log('🔄 Synchronisation terminée');\n    }\n\n    /**\n     * Traiter une opération de synchronisation\n     */\n    async processSyncOperation(operation) {\n        switch (operation.type) {\n            case 'create_request':\n                return await this.syncCreateRequest(operation.data);\n            case 'update_profile':\n                return await this.syncUpdateProfile(operation.data);\n            case 'mark_read':\n                return await this.syncMarkAsRead(operation.data);\n            default:\n                console.warn('⚠️ Type d\\'opération sync inconnue:', operation.type);\n        }\n    }\n\n    /**\n     * Synchroniser la création d'une demande\n     */\n    async syncCreateRequest(data) {\n        const response = await fetch('/api/mobile/citizen/requests', {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json',\n                'Authorization': `Bearer ${authToken}`\n            },\n            body: JSON.stringify(data)\n        });\n        \n        if (!response.ok) {\n            throw new Error(`Erreur sync create_request: ${response.status}`);\n        }\n        \n        // Invalider le cache des demandes\n        this.invalidatePattern('/api/mobile/citizen/requests');\n        \n        return await response.json();\n    }\n\n    /**\n     * Synchroniser la mise à jour du profil\n     */\n    async syncUpdateProfile(data) {\n        const response = await fetch('/api/mobile/citizen/profile', {\n            method: 'PUT',\n            headers: {\n                'Content-Type': 'application/json',\n                'Authorization': `Bearer ${authToken}`\n            },\n            body: JSON.stringify(data)\n        });\n        \n        if (!response.ok) {\n            throw new Error(`Erreur sync update_profile: ${response.status}`);\n        }\n        \n        // Invalider le cache du profil\n        this.invalidatePattern('/api/mobile/citizen/profile');\n        \n        return await response.json();\n    }\n\n    /**\n     * Invalider les entrées de cache correspondant à un pattern\n     */\n    invalidatePattern(pattern) {\n        const keysToDelete = Object.keys(this.cache).filter(key => key.includes(pattern));\n        \n        keysToDelete.forEach(key => {\n            delete this.cache[key];\n        });\n        \n        if (keysToDelete.length > 0) {\n            this.saveCacheToStorage();\n            console.log('🗑️ Cache invalidé:', keysToDelete.length, 'entrées pour pattern:', pattern);\n        }\n    }\n\n    /**\n     * Précharger les données critiques\n     */\n    async preloadCriticalData() {\n        if (!this.isOnline) {\n            return;\n        }\n\n        console.log('🚀 Préchargement des données critiques...');\n        \n        const criticalEndpoints = [\n            '/api/mobile/citizen/dashboard',\n            '/api/mobile/citizen/requests',\n            '/api/mobile/citizen/profile'\n        ];\n\n        for (const endpoint of criticalEndpoints) {\n            try {\n                const cacheKey = this.generateCacheKey(endpoint);\n                \n                // Vérifier si déjà en cache et valide\n                if (this.get(cacheKey)) {\n                    continue;\n                }\n\n                const response = await fetch(endpoint, {\n                    headers: {\n                        'Authorization': `Bearer ${authToken}`\n                    }\n                });\n\n                if (response.ok) {\n                    const data = await response.json();\n                    this.set(cacheKey, data, { priority: 'high', persistent: true });\n                    console.log('📦 Données préchargées:', endpoint);\n                }\n            } catch (error) {\n                console.error('❌ Erreur préchargement:', endpoint, error);\n            }\n        }\n    }\n\n    /**\n     * Obtenir les statistiques du cache\n     */\n    getStats() {\n        const entries = Object.keys(this.cache);\n        const totalSize = JSON.stringify(this.cache).length;\n        const validEntries = entries.filter(key => this.isCacheValid(this.cache[key]));\n        \n        return {\n            totalEntries: entries.length,\n            validEntries: validEntries.length,\n            expiredEntries: entries.length - validEntries.length,\n            totalSize: totalSize,\n            syncQueueSize: this.syncQueue.length,\n            lastSyncTime: this.lastSyncTime,\n            isOnline: this.isOnline\n        };\n    }\n\n    /**\n     * Afficher les statistiques du cache\n     */\n    logStats() {\n        const stats = this.getStats();\n        console.log('📊 Statistiques Cache SAMA CONAI:');\n        console.log('   📦 Entrées totales:', stats.totalEntries);\n        console.log('   ✅ Entrées valides:', stats.validEntries);\n        console.log('   ⏰ Entrées expirées:', stats.expiredEntries);\n        console.log('   💾 Taille totale:', Math.round(stats.totalSize / 1024), 'KB');\n        console.log('   📤 Queue sync:', stats.syncQueueSize, 'opérations');\n        console.log('   🔄 Dernière sync:', stats.lastSyncTime ? new Date(stats.lastSyncTime).toLocaleTimeString() : 'Jamais');\n        console.log('   🌐 État:', stats.isOnline ? 'En ligne' : 'Hors ligne');\n    }\n}\n\n// Instance globale du gestionnaire de cache\nconst cacheManager = new CacheManager();\n\n/**\n * Wrapper pour les appels fetch avec cache intelligent\n */\nasync function fetchWithCache(url, options = {}, cacheOptions = {}) {\n    const cacheKey = cacheManager.generateCacheKey(url, options.params || {});\n    \n    // Vérifier le cache d'abord\n    const cachedData = cacheManager.get(cacheKey);\n    if (cachedData && !options.forceRefresh) {\n        console.log('⚡ Données servies depuis le cache:', url);\n        return {\n            ...cachedData,\n            fromCache: true,\n            cacheTimestamp: cacheManager.cache[cacheKey].timestamp\n        };\n    }\n\n    // Si hors ligne et pas de cache, retourner erreur\n    if (!cacheManager.isOnline && !cachedData) {\n        throw new Error('Données non disponibles hors ligne');\n    }\n\n    // Si hors ligne mais cache disponible, le retourner avec avertissement\n    if (!cacheManager.isOnline && cachedData) {\n        console.log('📡 Mode hors ligne - données du cache (possiblement obsolètes):', url);\n        return {\n            ...cachedData,\n            fromCache: true,\n            offline: true,\n            cacheTimestamp: cacheManager.cache[cacheKey].timestamp\n        };\n    }\n\n    // Faire l'appel réseau\n    try {\n        console.log('🌐 Appel réseau:', url);\n        \n        const fetchOptions = {\n            ...options,\n            headers: {\n                'Content-Type': 'application/json',\n                ...options.headers\n            }\n        };\n\n        const response = await fetch(url, fetchOptions);\n        \n        if (!response.ok) {\n            throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n        }\n\n        const data = await response.json();\n        \n        // Mettre en cache si succès\n        if (data.success) {\n            cacheManager.set(cacheKey, data, {\n                priority: cacheOptions.priority || 'normal',\n                persistent: cacheOptions.persistent || false\n            });\n        }\n\n        return {\n            ...data,\n            fromCache: false,\n            networkTimestamp: Date.now()\n        };\n        \n    } catch (error) {\n        console.error('❌ Erreur réseau:', url, error);\n        \n        // En cas d'erreur, retourner le cache si disponible\n        if (cachedData) {\n            console.log('🔄 Fallback vers cache après erreur réseau:', url);\n            return {\n                ...cachedData,\n                fromCache: true,\n                networkError: error.message,\n                cacheTimestamp: cacheManager.cache[cacheKey].timestamp\n            };\n        }\n        \n        throw error;\n    }\n}\n\n/**\n * Fonction pour invalider le cache lors de modifications\n */\nfunction invalidateCache(pattern) {\n    cacheManager.invalidatePattern(pattern);\n}\n\n/**\n * Fonction pour ajouter une opération à la queue de sync\n */\nfunction addToSyncQueue(type, data) {\n    cacheManager.addToSyncQueue({ type, data });\n}\n\n/**\n * Fonction pour forcer la synchronisation\n */\nfunction forcSync() {\n    return cacheManager.syncPendingData();\n}\n\n/**\n * Fonction pour précharger les données critiques\n */\nfunction preloadData() {\n    return cacheManager.preloadCriticalData();\n}\n\n/**\n * Fonction pour obtenir les stats du cache\n */\nfunction getCacheStats() {\n    return cacheManager.getStats();\n}\n\n/**\n * Fonction pour nettoyer le cache\n */\nfunction cleanupCache() {\n    cacheManager.cleanup();\n}\n\n// Nettoyer le cache périodiquement\nsetInterval(() => {\n    cacheManager.cleanup();\n}, 60000); // Toutes les minutes\n\n// Précharger les données au démarrage si connecté\nif (cacheManager.isOnline) {\n    setTimeout(() => {\n        cacheManager.preloadCriticalData();\n    }, 2000);\n}\n\n// Exposer les fonctions globalement\nwindow.fetchWithCache = fetchWithCache;\nwindow.invalidateCache = invalidateCache;\nwindow.addToSyncQueue = addToSyncQueue;\nwindow.forcSync = forcSync;\nwindow.preloadData = preloadData;\nwindow.getCacheStats = getCacheStats;\nwindow.cleanupCache = cleanupCache;\nwindow.cacheManager = cacheManager;\n\nconsole.log('🚀 Système de cache SAMA CONAI initialisé');"