/**\n * Service Worker SAMA CONAI\n * Cache avancé et synchronisation en arrière-plan\n */\n\nconst CACHE_NAME = 'sama-conai-v1.0.0';\nconst STATIC_CACHE = 'sama-conai-static-v1.0.0';\nconst API_CACHE = 'sama-conai-api-v1.0.0';\n\n// Ressources à mettre en cache\nconst STATIC_ASSETS = [\n    '/',\n    '/cache_manager.js',\n    '/performance_monitor.js',\n    '/offline_mode_implementation.js',\n    'https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700;800&display=swap',\n    'https://cdn.jsdelivr.net/npm/chart.js'\n];\n\n// Installation du Service Worker\nself.addEventListener('install', event => {\n    console.log('🔧 Installation du Service Worker SAMA CONAI');\n    \n    event.waitUntil(\n        caches.open(STATIC_CACHE)\n            .then(cache => {\n                console.log('📦 Mise en cache des ressources statiques');\n                return cache.addAll(STATIC_ASSETS);\n            })\n            .then(() => self.skipWaiting())\n    );\n});\n\n// Activation du Service Worker\nself.addEventListener('activate', event => {\n    console.log('✅ Activation du Service Worker SAMA CONAI');\n    \n    event.waitUntil(\n        caches.keys().then(cacheNames => {\n            return Promise.all(\n                cacheNames.map(cacheName => {\n                    if (cacheName !== STATIC_CACHE && cacheName !== API_CACHE) {\n                        console.log('🗑️ Suppression ancien cache:', cacheName);\n                        return caches.delete(cacheName);\n                    }\n                })\n            );\n        }).then(() => self.clients.claim())\n    );\n});\n\n// Interception des requêtes\nself.addEventListener('fetch', event => {\n    const { request } = event;\n    const url = new URL(request.url);\n    \n    // Stratégie pour les ressources statiques\n    if (STATIC_ASSETS.some(asset => request.url.includes(asset))) {\n        event.respondWith(\n            caches.match(request)\n                .then(response => {\n                    if (response) {\n                        return response;\n                    }\n                    return fetch(request).then(response => {\n                        const responseClone = response.clone();\n                        caches.open(STATIC_CACHE)\n                            .then(cache => cache.put(request, responseClone));\n                        return response;\n                    });\n                })\n        );\n        return;\n    }\n    \n    // Stratégie pour les API\n    if (url.pathname.startsWith('/api/')) {\n        event.respondWith(\n            fetch(request)\n                .then(response => {\n                    // Mettre en cache seulement les GET réussis\n                    if (request.method === 'GET' && response.ok) {\n                        const responseClone = response.clone();\n                        caches.open(API_CACHE)\n                            .then(cache => {\n                                cache.put(request, responseClone);\n                            });\n                    }\n                    return response;\n                })\n                .catch(() => {\n                    // Fallback vers le cache en cas d'erreur\n                    if (request.method === 'GET') {\n                        return caches.match(request);\n                    }\n                    throw new Error('Réseau indisponible');\n                })\n        );\n        return;\n    }\n    \n    // Stratégie par défaut\n    event.respondWith(\n        fetch(request).catch(() => caches.match(request))\n    );\n});\n\n// Synchronisation en arrière-plan\nself.addEventListener('sync', event => {\n    console.log('🔄 Synchronisation en arrière-plan:', event.tag);\n    \n    if (event.tag === 'background-sync') {\n        event.waitUntil(\n            // Ici on pourrait synchroniser les données en attente\n            Promise.resolve()\n        );\n    }\n});\n\n// Gestion des messages\nself.addEventListener('message', event => {\n    if (event.data && event.data.type === 'SKIP_WAITING') {\n        self.skipWaiting();\n    }\n    \n    if (event.data && event.data.type === 'GET_CACHE_SIZE') {\n        caches.open(API_CACHE).then(cache => {\n            cache.keys().then(keys => {\n                event.ports[0].postMessage({\n                    type: 'CACHE_SIZE',\n                    size: keys.length\n                });\n            });\n        });\n    }\n});\n\nconsole.log('🚀 Service Worker SAMA CONAI chargé');"