#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Script de test complet pour toutes les vagues de donn√©es de d√©mo
"""

def test_all_demo_waves():
    """
    Teste toutes les vagues de donn√©es de d√©mo et g√©n√®re un rapport complet
    """
    print("üß™ TEST COMPLET DES DONN√âES DE D√âMO SAMA CONAI")
    print("=" * 60)
    
    try:
        # Collecte des donn√©es
        info_requests = env['request.information'].search([])
        whistleblowing_alerts = env['whistleblowing.alert'].search([])
        info_stages = env['request.information.stage'].search([])
        wb_stages = env['whistleblowing.alert.stage'].search([])
        refusal_reasons = env['request.refusal.reason'].search([])
        
        print(f"üìä STATISTIQUES G√âN√âRALES")
        print(f"   - Demandes d'information: {len(info_requests)}")
        print(f"   - Signalements d'alerte: {len(whistleblowing_alerts)}")
        print(f"   - √âtapes d'information: {len(info_stages)}")
        print(f"   - √âtapes de signalement: {len(wb_stages)}")
        print(f"   - Motifs de refus: {len(refusal_reasons)}")
        print()
        
        # Analyse des demandes d'information
        print("üìã ANALYSE DES DEMANDES D'INFORMATION")
        print("-" * 40)
        
        # Par √©tat
        states_count = {}
        for request in info_requests:
            state = request.state
            states_count[state] = states_count.get(state, 0) + 1
        
        print("   √âtats:")
        for state, count in sorted(states_count.items()):
            percentage = (count / len(info_requests)) * 100 if info_requests else 0
            print(f"     - {state}: {count} ({percentage:.1f}%)")
        
        # Par qualit√© de demandeur
        qualities_count = {}
        for request in info_requests:
            quality = request.requester_quality
            qualities_count[quality] = qualities_count.get(quality, 0) + 1
        
        print("   Qualit√©s de demandeurs:")
        for quality, count in sorted(qualities_count.items()):
            percentage = (count / len(info_requests)) * 100 if info_requests else 0
            print(f"     - {quality}: {count} ({percentage:.1f}%)")
        
        # Demandes avec contenu riche
        requests_with_response = len([r for r in info_requests if r.response_body])
        refused_requests = len([r for r in info_requests if r.is_refusal])
        overdue_requests = len([r for r in info_requests if r.is_overdue])
        
        print("   Contenu:")
        print(f"     - Avec r√©ponse: {requests_with_response}")
        print(f"     - Refus√©es: {refused_requests}")
        print(f"     - En retard: {overdue_requests}")
        print()
        
        # Analyse des signalements d'alerte
        print("üö® ANALYSE DES SIGNALEMENTS D'ALERTE")
        print("-" * 40)
        
        # Par cat√©gorie
        categories_count = {}
        for alert in whistleblowing_alerts:
            category = alert.category
            categories_count[category] = categories_count.get(category, 0) + 1
        
        print("   Cat√©gories:")
        for category, count in sorted(categories_count.items()):
            percentage = (count / len(whistleblowing_alerts)) * 100 if whistleblowing_alerts else 0
            print(f"     - {category}: {count} ({percentage:.1f}%)")
        
        # Par priorit√©
        priorities_count = {}
        for alert in whistleblowing_alerts:
            priority = alert.priority
            priorities_count[priority] = priorities_count.get(priority, 0) + 1
        
        print("   Priorit√©s:")
        for priority, count in sorted(priorities_count.items()):
            percentage = (count / len(whistleblowing_alerts)) * 100 if whistleblowing_alerts else 0
            print(f"     - {priority}: {count} ({percentage:.1f}%)")
        
        # Par √©tat
        wb_states_count = {}
        for alert in whistleblowing_alerts:
            state = alert.state
            wb_states_count[state] = wb_states_count.get(state, 0) + 1
        
        print("   √âtats:")
        for state, count in sorted(wb_states_count.items()):
            percentage = (count / len(whistleblowing_alerts)) * 100 if whistleblowing_alerts else 0
            print(f"     - {state}: {count} ({percentage:.1f}%)")
        
        # Signalements avec contenu riche
        anonymous_alerts = len([a for a in whistleblowing_alerts if a.is_anonymous])
        alerts_with_investigation = len([a for a in whistleblowing_alerts if a.investigation_notes])
        resolved_alerts = len([a for a in whistleblowing_alerts if a.resolution])
        urgent_alerts = len([a for a in whistleblowing_alerts if a.priority == 'urgent'])
        
        print("   Contenu:")
        print(f"     - Anonymes: {anonymous_alerts}")
        print(f"     - Avec investigation: {alerts_with_investigation}")
        print(f"     - R√©solus: {resolved_alerts}")
        print(f"     - Urgents: {urgent_alerts}")
        print()
        
        # Test des capacit√©s d'analyse
        print("üìä CAPACIT√âS D'ANALYSE")
        print("-" * 40)
        
        # Analyse temporelle
        from datetime import datetime, timedelta
        
        recent_requests = env['request.information'].search([
            ('request_date', '>=', (datetime.now() - timedelta(days=30)).strftime('%Y-%m-%d'))
        ])
        
        recent_alerts = env['whistleblowing.alert'].search([
            ('alert_date', '>=', (datetime.now() - timedelta(days=30)).strftime('%Y-%m-%d'))
        ])
        
        print(f"   Activit√© r√©cente (30 derniers jours):")
        print(f"     - Nouvelles demandes: {len(recent_requests)}")
        print(f"     - Nouveaux signalements: {len(recent_alerts)}")
        
        # Performance
        responded_requests = env['request.information'].search([('state', '=', 'responded')])
        avg_response_time = 0
        if responded_requests:
            total_days = 0
            count = 0
            for request in responded_requests:
                if request.request_date and request.response_date:
                    request_dt = datetime.strptime(request.request_date, '%Y-%m-%d %H:%M:%S')
                    response_dt = datetime.strptime(request.response_date, '%Y-%m-%d %H:%M:%S')
                    days = (response_dt - request_dt).days
                    total_days += days
                    count += 1
            avg_response_time = total_days / count if count > 0 else 0
        
        print(f"   Performance:")
        print(f"     - Temps moyen de r√©ponse: {avg_response_time:.1f} jours")
        print(f"     - Taux de r√©ponse: {(len(responded_requests)/len(info_requests)*100):.1f}%" if info_requests else "     - Taux de r√©ponse: 0%")
        print()
        
        # V√©rification de la qualit√© des donn√©es
        print("üîç QUALIT√â DES DONN√âES")
        print("-" * 40)
        
        quality_issues = []
        
        # V√©rifier les demandes refus√©es
        for request in info_requests:
            if request.is_refusal:
                if not request.refusal_reason_id:
                    quality_issues.append(f"Demande {request.name}: refus sans motif")
                if not request.refusal_motivation:
                    quality_issues.append(f"Demande {request.name}: refus sans motivation")
        
        # V√©rifier les signalements en investigation
        investigating_alerts = env['whistleblowing.alert'].search([('state', '=', 'investigation')])
        for alert in investigating_alerts:
            if not alert.investigation_notes:
                quality_issues.append(f"Signalement {alert.name}: investigation sans notes")
        
        # V√©rifier les signalements r√©solus
        resolved_alerts_obj = env['whistleblowing.alert'].search([('state', '=', 'resolved')])
        for alert in resolved_alerts_obj:
            if not alert.resolution:
                quality_issues.append(f"Signalement {alert.name}: r√©solu sans r√©solution")
        
        if quality_issues:
            print("   ‚ö†Ô∏è  Probl√®mes d√©tect√©s:")
            for issue in quality_issues[:5]:  # Limiter √† 5 pour la lisibilit√©
                print(f"     - {issue}")
            if len(quality_issues) > 5:
                print(f"     ... et {len(quality_issues) - 5} autres probl√®mes")
        else:
            print("   ‚úÖ Aucun probl√®me de qualit√© d√©tect√©")
        print()
        
        # Test des vues et fonctionnalit√©s
        print("üéØ TEST DES FONCTIONNALIT√âS")
        print("-" * 40)
        
        # Test des actions
        try:
            action_info = env.ref('sama_conai.action_information_request')
            print(f"   ‚úÖ Action demandes d'information: {action_info.name}")
        except:
            print("   ‚ùå Action demandes d'information: ERREUR")
        
        try:
            action_wb = env.ref('sama_conai.action_whistleblowing_alert', raise_if_not_found=False)
            if action_wb:
                print(f"   ‚úÖ Action signalements: {action_wb.name}")
            else:
                print("   ‚ö†Ô∏è  Action signalements: NON TROUV√âE")
        except:
            print("   ‚ùå Action signalements: ERREUR")
        
        # Test des vues
        view_types = ['kanban', 'list', 'form', 'graph', 'pivot']
        for view_type in view_types:
            try:
                view = env['ir.ui.view'].search([
                    ('model', '=', 'request.information'),
                    ('type', '=', view_type)
                ], limit=1)
                if view:
                    print(f"   ‚úÖ Vue {view_type}: {view.name}")
                else:
                    print(f"   ‚ö†Ô∏è  Vue {view_type}: NON TROUV√âE")
            except:
                print(f"   ‚ùå Vue {view_type}: ERREUR")
        print()
        
        # √âvaluation globale
        print("üéâ √âVALUATION GLOBALE")
        print("-" * 40)
        
        # Crit√®res de succ√®s
        criteria = {
            "Nombre de demandes": len(info_requests) >= 6,
            "Nombre de signalements": len(whistleblowing_alerts) >= 6,
            "Diversit√© des √©tats (demandes)": len(states_count) >= 4,
            "Diversit√© des cat√©gories (signalements)": len(categories_count) >= 4,
            "Demandes avec r√©ponse": requests_with_response >= 2,
            "Signalements r√©solus": resolved_alerts >= 1,
            "Qualit√© des donn√©es": len(quality_issues) == 0,
            "Contenu riche": (requests_with_response + alerts_with_investigation) >= 3
        }
        
        passed_criteria = sum(criteria.values())
        total_criteria = len(criteria)
        success_rate = (passed_criteria / total_criteria) * 100
        
        print(f"   Crit√®res valid√©s: {passed_criteria}/{total_criteria} ({success_rate:.1f}%)")
        print()
        
        for criterion, passed in criteria.items():
            status = "‚úÖ" if passed else "‚ùå"
            print(f"   {status} {criterion}")
        
        print()
        
        if success_rate >= 90:
            print("üèÜ EXCELLENT! Donn√©es de d√©mo compl√®tes et de haute qualit√©")
            print("   Pr√™t pour la d√©monstration et la formation des utilisateurs")
        elif success_rate >= 75:
            print("üëç BIEN! Donn√©es de d√©mo satisfaisantes")
            print("   Quelques am√©liorations mineures possibles")
        elif success_rate >= 50:
            print("‚ö†Ô∏è  MOYEN. Donn√©es de d√©mo basiques")
            print("   Am√©liorations n√©cessaires pour une meilleure exp√©rience")
        else:
            print("‚ùå INSUFFISANT. Donn√©es de d√©mo incompl√®tes")
            print("   R√©vision majeure n√©cessaire")
        
        print()
        print("üìà RECOMMANDATIONS POUR L'ANALYSE DE DONN√âES:")
        print("   1. Utiliser la vue Kanban pour le suivi visuel")
        print("   2. Explorer les vues Graph pour les tendances")
        print("   3. Utiliser Pivot pour les analyses crois√©es")
        print("   4. Tester les filtres avanc√©s")
        print("   5. Configurer des tableaux de bord personnalis√©s")
        
        return success_rate >= 75
        
    except Exception as e:
        print(f"‚ùå Erreur lors du test: {e}")
        import traceback
        traceback.print_exc()
        return False

# Ex√©cuter le test si dans le contexte Odoo
try:
    result = test_all_demo_waves()
    print("\\n" + "=" * 60)
    if result:
        print("üéØ SAMA CONAI: DONN√âES DE D√âMO VALID√âES!")
        print("   Module pr√™t pour la formation et la d√©monstration")
    else:
        print("üîß SAMA CONAI: AM√âLIORATIONS N√âCESSAIRES")
        print("   R√©viser les donn√©es avant la mise en production")
except NameError:
    print("‚ùå Ce script doit √™tre ex√©cut√© dans le shell Odoo.")
    print("   Usage: ./odoo-bin shell -c odoo.conf -d your_database")
    print("   Puis: exec(open('scripts/test_all_demo_waves.py').read())")